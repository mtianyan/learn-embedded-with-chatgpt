当然可以，下面是关于 ARM 以及 SoC 相关概念的清晰介绍，帮助你更好地理解嵌入式系统开发中软件如何驱动硬件。

---

## 一、ARM 介绍

### 1. 什么是 ARM？

ARM（**Advanced RISC Machine**）是一种基于 RISC（**精简指令集计算机**）架构的处理器设计，由英国 ARM 公司（原 Acorn RISC Machine）提出。

> ARM 本身并不制造芯片，而是提供 CPU 的架构和 IP 授权，全球上千家芯片厂商（如 NXP、高通、三星、ST、TI、瑞芯微等）使用 ARM 的 IP 设计并制造符合自己需求的芯片。

---

### 2. ARM 的特点

* **低功耗、低成本**：非常适合嵌入式设备、电池供电设备。
* **高性能**：尤其是近代 Cortex-A 系列已足以驱动 Linux 系统。
* **良好的生态系统**：有完善的编译器（如 GCC、LLVM）、调试器、操作系统（如 Linux、RTOS）等支持。
* **可裁剪性强**：IP 授权机制允许厂商定制不同级别的 CPU 内核（例如加不加 MMU/FPU）。

---

### 3. ARM 的核心分类（Cortex 系列）

ARM Cortex 系列内核按用途分为三大类：

| 类型       | 描述                         | 示例芯片            |
| -------- | -------------------------- | --------------- |
| Cortex-A | 高性能应用处理器，支持 Linux/Android  | i.MX6ULL、RK3288 |
| Cortex-R | 实时处理器，适合对时延敏感的场景（如汽车、工业控制） | TI Hercules     |
| Cortex-M | 面向微控制器，适用于低功耗嵌入式           | STM32、NRF52     |

---

## 二、理解 CPU 核 和 SoC 概念

### 1. CPU 核（Core）

* CPU 核指的是执行指令的核心计算单元。
* 它包括寄存器、ALU（算术逻辑单元）、指令控制器等。
* 一颗芯片可以有一个或多个 CPU 核（单核、双核、四核等）。

---

### 2. SoC（System on Chip，片上系统）

SoC 是一种集成度非常高的芯片，把一个系统的所有功能模块集成到单颗芯片中：

**SoC 通常包含：**

* **CPU 核**（比如 ARM Cortex-A）
* **内存控制器**（DDR 控制器）
* **外设接口**（UART、SPI、I2C、USB、ETH 等）
* **图形加速器 GPU**（可选）
* **音视频编解码器**（如 VPU）
* **电源管理单元**
* **中断控制器、DMA 控制器**

SoC 是嵌入式开发的主要硬件平台。

---

### 3. i.MX6ULL 是什么？

* i.MX6ULL 是 NXP（恩智浦）基于 **ARM Cortex-A7** 核心的 SoC。
* 特点：低功耗、高集成度、支持运行 Linux 操作系统。
* 常用于工业控制、物联网、医疗设备、信息终端等领域。

---

## 三、ARM 芯片生态环境

ARM 芯片生态系统非常完善，包含：

* **编译工具链**：如 arm-none-eabi-gcc，或 arm-linux-gnueabihf-gcc。
* **调试工具**：如 JLink、OpenOCD、GDB。
* **开发板资源**：如树莓派、友善之臂、野火、正点原子等。
* **操作系统支持**：如 u-boot、Linux、FreeRTOS。
* **厂商SDK**：如 NXP 的 MCUXpresso、STM32CubeMX。

---

## 四、总结

| 概念        | 简述                                    |
| --------- | ------------------------------------- |
| ARM       | 一种处理器架构，以低功耗和高效性能为特点                  |
| CPU核      | 实际执行程序指令的处理器核心                        |
| SoC       | 集成了 CPU 核、存储接口、外设接口等模块的一颗“系统芯片”       |
| Cortex 系列 | ARM 提供的核心 IP 类型，分为 A（应用）、R（实时）、M（微控制） |

---

如果你接下来还要学习 **裸机驱动开发、Linux 移植、寄存器控制、外设驱动等内容**，掌握这些基础将非常关键。

需要我继续介绍 i.MX6ULL 的启动流程、内存布局、开发环境搭建吗？

1.课程学习及环境搭建

# 一、课程学习

## 1.学习内容

- ARM核学习
- imx6ull 可以跑Linux
- stm32f103c8t6
- 硬件外设学习 摄像头，传感器

把imx6ull 当成单片机来用

换一款芯片，如何适配，不读死书

## 2.学习方法

- 了解ARM核的工作原理
- 掌握ARM汇编指令及异常处理: 基本不会使用汇编编程,操作系统公司，执行效率高。不可缺少，程序最前面的那部分代码
- 掌握硬件原理图阋读: 硬件工程师,能阅读，能知道被cpu哪个脚控制
- 掌握常用硬件外设工作原理: 产品外设不管哪个公司都是一样的，摄像头厂家也很多，行业标准，基本的工作原理是一样的。看到一个外设知道怎么去驱动他
- 了解芯片控制器相关寄存器设置: 开关做不同的设置，完成不同的操作

# 二、ARM指令模拟器环境搭建

## 1.keil软件

KEIL是公司的名称，有时候也指KEIL公司的所有软件开发工具，目前2005年Keil由ARM公司收购，成为ARM的公司之一。

MDK (Microcontroller Development Kit),也称MPK-ARM、 KEIL MDK、 RealView MDK、 KEILFor ARM，都是同一个东西。ARM公司现在统一使用MDK-ARM的称呼，MDK的设备数据库中有很多厂商的芯片，是专为微控制器开发的工具，为满足基于MCU进行嵌入式软件开发的工程师需求而设计支持ARM7，ARM9，Cortex-M4/M3/M1，Cortex-RO/R3/R4等ARM微控制器内核。

MCU（Microcontroller Unit，微控制器单元），又称单片机或微控制器，是一种将​​中央处理器（CPU）、存储器、定时器/计数器及多种输入/输出接口（如USB、ADC、UART等）集成在单一芯片上的微型计算机系统​​。

https://www.keil.com/download/product/

![](http://cdn.pic.funpython.cn/image/202507261937844.png)




## 2.激活软件
## 3.Legacy support

老的arm 7 arm9 不支持

MDK Version 5 uses Software Packs to support a microcontroller device and to use middleware. Tomaintain backward compatibility with MDK Version 4 you may install Legacy Support. This mightbe necessary for two reasons:
.To maintain projects created with MDK Version 4 without migrating to Software Packs.
To use older devices that are not supported by a Device Family Pack.
MDK版本5使用软件包来支持微控制器设备和使用中间件。要保持与MDK版本4的向后兼容性，您可以安装旧版支持。这可能是必要的，原因有两个:
维护使用MDK版本4创建的项目，而无需迁移到软件包
使用设备系列包不支持的旧设备

https://www2.keil.com/mdk5/legacy

![](http://cdn.pic.funpython.cn/image/202507262252148.png)

![](http://cdn.pic.funpython.cn/image/202507262252006.png)

这两个安装包需要安装在一个路径下

![](http://cdn.pic.funpython.cn/image/202507262258494.png)


# 第1章芯片产业链及ARM核介绍


# 2.ARM核介绍

一、芯片产业链

- 1.CPU核

1.CPU核
CPU又叫中央处理器，其主要功能是进行运算和逻辑运算，内部结构大概可以分为控制单元、算术逻辑单元和存储单元等几个部分。按照其处理信息的字长可以分为:八位微处理器、十六位微处理器、三十二位微处理器以及六十四位微处理器等等。

除法运算很特殊，cpu一般无法直接除法。因为除不尽

一次性可以处理多少长度的数据

![](http://cdn.pic.funpython.cn/image/202507262302279.png)

### clock 单元，人的心脏，时钟信号(电压信号按频率) cpu主频 2.6ghz

外围电压时钟信号 改大一点点可以超频运行

![](http://cdn.pic.funpython.cn/image/202507262304340.png)

读取寄存器中的机器码，通过预取电路

cpu 内部很多寄存器。高速cache->拿到数据和指令

ghz 内存1333mhz

cpu ghz 火箭拉内存乌龟

高速缓存比内存快很多。for循环指令固定


### CPU厂家主要工作:

机器码设计 0101 arm 和 intel 不一样

java编译后是字节码，java虚拟机把字节码翻译成机器码

主频 

高速缓存(cache)

多核集成

硬件浮点运算

软浮点 1.2 + 1.3 翻译成了很多条指令，如果支持硬件浮点，一条指令既可以

数据运算

功耗 电脑功耗高

CISC: Complex Instruction Set Computer，复杂指令集计算机: 

机器码指令宽度不固定，一条指令对应精简指令10条

RISC:Reduced Instruction Set Computer，精简指令集计算机

机器码指令宽度固定

### (1)ARM

ARM是Advanced RIsc Machines的缩写，它是一家微处理器行业的知名企业，该企业设计了大量高性能、廉价、低功耗的RISC(精简指令集)处理器ARM 公司的特点是只设计芯片，而不生产。它将技术授权给半导体厂商，并提供服务。

![](http://cdn.pic.funpython.cn/image/202507262315370.png)

芯片生产技术很高，arm把技术卖给别人。真正的cpu核设计师很难的。

靠授权赚钱，一片芯片提成几美分，聪明的大脑

国外只做自己的部分，不做全链

华为海思也可以设计，制造需要光刻机

ARM将其芯片设计技术(内核、体系扩展、微处理器和系统芯片方案)授权给Intel，SamsungTI，高通(Qualcomm)，意法半导体等半导体制造商，这些厂商拿到ARM内核以后，再设计外围的各种控制器，和ARM核整合成一块SOC芯片

arm不关心外围如摄像头，显示屏等，只关心cpu核指令，计算








### (2)MIPS

(2)MIPS
MIPS(Million Instructions Per Second)技术公司是美国一家设计制造高性能、高档次及嵌入式32位和64位处理器的厂商，在RISC处理器方面占有重要地位。
MIPS的商业模式和ARM相似，也是研发处理器内核，将知识产权授权给其他公司，我国的国产处理器厂商龙芯就是获得MIPS32和MIPS64架构的授权，借此开发龙芯CPU。




### (3)PowerPc

PowerPC (英语:Performance Optimization With Enhanced RIsc-Performance
Computing，有时简称PPC)是一种精简指令集(RISC)架构的中央处理器(CPU)，其基本的设计源自IBM的POWER(Performance Optimized With Enhanced RIsC);


### (4)Intel

X86架构是复杂指令集工主要用于PC产业。

### （5）RISC-V

RISC-V(读作“RISC-FIVE”)是基于精简指令集计算(RISC)原理建立的开放指令集架构(ISA)，V表示为第五代RISC(精简指令集计算机),表示此前已经有四代RISC处理器原型芯片。每一代RISC处理器都是在同一人带领下完成，那就是加州大学伯克利分校的David A.Patterson教授。与大多数ISA相反，RISC-V ISA可以免费地用于所有希望的设备中，允许任何人设计、制造和销售RISC-V芯片和软件。

阿里平头哥用了这个，开源很重要

##  2.SOC芯片

2.SOC芯片
SOc(System On chip:CPU核 +外围控制器),片上系统，即在一块芯片上集成一整个信息处理系统，简单来说 SoC芯片是在中央处理器CPU的基础上扩展专用接口的超大规模集成电路，是智能设备的“大脑”。


![](http://cdn.pic.funpython.cn/image/202507262326087.png)

一般称呼的手机cpu就是soc了，电脑上cpu就是cpu，控制器
是南桥 / 北桥芯片组，或pch 平台控制器中心

### 📱 手机：SoC（System on Chip）

* 手机用的是 **SoC**，中文叫“系统级芯片”。
* SoC 是**集成度极高的芯片**，把 CPU、GPU、DSP、NPU、基带（通信模块）、Wi-Fi、蓝牙、电源管理 等都集成到一颗芯片里。
* 代表例子：

  * 高通 Snapdragon（骁龙）
  * 苹果 A 系列（A17 等）
  * 联发科 天玑
  * 华为 麒麟

---

### 💻 电脑：CPU + 其他组件

* 电脑的架构更“分离”，不是一颗芯片搞定一切，而是：

  * **CPU**：中央处理器（处理通用计算）
  * **GPU**：显卡（图形运算）
  * **内存控制器**：大多数已集成到 CPU 里
  * **南桥 / 北桥芯片组**（旧时代的概念）
  * **PCH（平台控制器中心）**：现在 Intel/AMD 用来替代南桥，处理 USB、音频、SATA 等 I/O


lcd 显示屏 csi 控制摄像头

华为，高通，设计soc，cpu一样，其他控制器不同

## (1)主流厂家

德州仪器(TI)
高通(Qualcomm)
三星(Samsung)
恩智浦(NXP)
全志(Allwinner Technology)
华为海思(Hisilicon)
联发科(MTK)
瑞星薇(rockchip)

## (2)产品解决方案

手机解决方案
平板解决方案
智能电视解决方案




## 3.产品

3.产品

特斯拉
小米
华为
格力
大疆
飞利浦


芯片公司和产品公司工作，工资多可以去芯片公司，产品公司可以创业

# 1-3ARM核发展介绍

![](http://cdn.pic.funpython.cn/image/202507262353889.png)


应用就是手机这类， 实时处理是工业领域，单片机

课程里用到的是cortex-a7

![](http://cdn.pic.funpython.cn/image/202507262354439.png)


ARM公司在经典处理器ARM11以后的产品改用Cortex命名，并分成A、R和M三类，旨在为各种不同的市场提供服务。Cortex系列属于ARMv7架构，由于应用领域不同，基于v7架构的Cortex处理器系列所采用的技术也不相同，基于V7A的称为Cortex-A系列，基于V7R的称为Cortex-R系列，基于v7M的称为Cortex-M系列。

![](http://cdn.pic.funpython.cn/image/202507262354175.png)


armv8 完全兼容armv7

![](http://cdn.pic.funpython.cn/image/202507262356116.png)

FPU 是“浮点运算单元”的统称，
VFP 是 ARM 架构中的一种具体 FPU 实现。

## (1)VFP
VFP(Vector Floating-point Coprocessor for ARM)向量浮点运算单元(协处理器)。它提供低成本的单精度和倍精度浮点运算能力，并完全相容于ANSI/IEEE Std 754-1985 二进制浮点算数标准。VFP 提供大多数适用于浮点运算的应用，例如PDA、I智慧手机、语音压缩与解压、3D图像以及数位音效、打印机、机上盒，和汽车应用等。

## (2)Jazelle
Jazelle是ARM体系结构的一种相关技术，用于在处理器指令层次对JAVA加速。ARM的Jazelle技术使Java加速得到比基于软件的Java虚拟机(JVM)高得多的性能，和同等的非java加速核相比功耗降低80%.

cpu核直接解析部分字节码

## (3)Thumb
表示ARM处理器可以工作在Thumb状态，执行Thumb指令集。ARM指令集是32bit的指令集，在Thumb状态执行的指令集是16bit的。Thumb指令集不是完整的指令集，它是ARM指令集的子集。但是Thumb指令具有更高的代码密度，即占用存储空间小，仅为ARM代码规格的65%，但其性能却下降的很少。所以，Thumb指令集使ARM处理器能应用到有限的存储带宽，并且，代码密度要求很高的嵌入式系统中去。
Thumb-2 是 Thumb 指令集的一项主要增强功能，并且由 ARMv6T2 和 ARMV7M体系结构定义。Thumb-2 提供了几乎与 ARM 指令集完全一样的功能。 它兼有16 位和 32 位指令，并可检索与ARM 类似的性能，但其代码密度与 Thumb 代码类似。

单片机上面运行内存是几十kb，代码体积就变重要了

## (4)TrustZone

TrustZone是ARM针对消费电子设备设计的一种硬件架构，其目的是为消费电子产品构建一个安全框架来抵御各种可能的攻击。

TrustZone在概念上将SoC的硬件和软件资源划分为安全(Secure World)和非安全(NormalWorld)两个世界，所有需要保密的操作在安全世界执行(如指纹识别、密码处理、数据加解密、安全认证等)，其余操作在非安全世界执行(如用户操作系统、各种应用程序等)。

![](http://cdn.pic.funpython.cn/image/202507270003166.png)

木马程序没法进入安全世界。芯片公司才知道如何进入

## (5)SIMD
SIMD，即 single instruction multiple data，单指令流多数据流，也就是说一次运算指令可以执行多个数据流，从而提高程序的运算速度，实质是通过 数据并行 来提高执行效率

![](http://cdn.pic.funpython.cn/image/202507270005274.png)

数据并行直接相加

## (6)NEON

ARMv7之后，将SIMD升级为 NEON技术 相当于**扩展了浮点运算向量表**有一个VFS的二维向量表，将数据存放到这个表中，cpu可以一次性取某个区域进行执行，**NEON就是SIMD的升级 相当于将上面SIMD执行指令的表格长度与宽度进行扩展，提升了数据集的压缩算法**。 NENO可以进行指令扩展来实现相关功能，但我们一般不使用，如果做一些GPU相关的工作就需要利用NENO的浮点运算特性。 可用于加速多媒体和信号处理算法(如视频编码/解码)、2D/3D图形、游戏、音频和语音处理、图像处理技术、电话和声音合成，其性能至少为ARMv5的3倍，为ARMV6 SIMD性能的两倍 在SIMD的基础上提升了两倍效率 所以运算速度的加快不是单纯的提升CPU的频率 通过这两个技术提升指令执行的方式，还有其他的方法(比如增加二级缓存)

# ARM核(ARMv7)工作模式

![](http://cdn.pic.funpython.cn/image/202507272304662.png)

人的角色，工程师，病人，

正打游戏需要去接电话，产生中断，切换工作模式

异常情况很多，正常情况只有user/system两种

安全/非安全，有些模式，只能在安全状态下

状态位代表这个模式。 

工作模式可以软件切换，也可以异常切换

## 1.Privilege level(权限级别)

![](http://cdn.pic.funpython.cn/image/202507272309353.png)

安全状态 pl0 pl1

非安全状态 pl0 pl1 pl2

虚拟化扩展，虚拟机里运行操作系统

hyp 为虚拟化设计的

user 为非特权级别

## 2. ARM processor modes

![](http://cdn.pic.funpython.cn/image/202507272311837.png)

### (1)User mode

**An operating system runs applications in User mode to restrict the use of systemresources. **Software executing in User mode executes at pLp. Execution in User mode issometimes described as unprivileged execution.
操作系统在用户模式下运行应用程序以限制系统资源的使用。在用户模式下执行的软件在PL0执行。
在用户模式下执行有时被描述为非特权执行。
Application programs normally execute in User mode, and any program executed in User mode:
Makes only unprivileged accesses to system resources, meaning it cannot access protected
system resources.
Makes only unprivileged access to memory.
**Cannot change mode except by causing an exception,**

应用程序通常在用户模式下执行，而在用户模式下执行的任何程序:

- 仅对系统资源进行非特权访问，这意味着它无法访问受保护的系统资源。
- 仅对内存进行非特权访问
- 除非引起异常，否则无法更改模式，


用户模式是用户程序的工作模式，它运行在操作系统的用户态，它没有权限去操作其它硬件资源，**只能执行处理自己的数据，也不能切换到其它模式下，要想访问硬件资源或切换到其它模式只能通过软中断或产生异常。**

### (2)system mode

![](http://cdn.pic.funpython.cn/image/202507272313166.png)

系统模式是特权模式，不受用户模式的限制。用户模式和系统模式共用一套寄存器，操作系统在该模式下可以方便的访问用户模式的寄存器，而且操作系统的一些特权任务可以使用这个模式访问一些受控的资源。


### (3)Supervisor mode

Supervisor mode is the default mode to which a Supervisor Call exception is taken. **Executing aSVC (Supervisor Call) instruction generates a Supervisor Call exception, that is takento Supervisor mode.** A processor enters Supervisor mode on Reset.


Supervisor模式是采取Supervisor Call异常的默认模式。执行SVC(Supervisor Call) 指令会生成Supervisor Call异常，该异常被带到Supervisor模式。处理器在复位时进入Supervisor模式。

管理模式是CPU上电后默认模式，因此在该模式下主要用来做系统的初始化，软中断处理也在该模式下。当用户模式下的用户程序请求使用硬件资源时，通过软件中断进入该模式。

### (4)Abort mode

Abort mode is the default mode to which a Data Abort exception or Prefetch Abort exception istaken.

中止模式是数据中止异常或预取中止异常的默认模式采取。

中止模式用于支持虚拟内存或存储器保护，**当用户程序访问非法地址，没有权限读取的内存地址时，会进入该模式**，linux下编程时经常出现的segment fault通常都是在该模式下抛出返回的。

### (5)Undefined mode

Undefined mode is the default moderto which an instruction-related exception, including anyattempt to execute an UNDEFINED instruction, is taken.

未定义模式是与指令相关的异常(包括任何执行未定义指令的尝试)采取的默认模式。

### (6)FIQ mode

FIQ mode is the default mode to which an FIQ interrupt is taken.

FIQ模式是采用FIQ中断的默认模式。

快速中断模式是相对一般中断模式而言的，它是用来处理对**时间要求比较紧急的中断请求主要用于高連数据传输及通道处理中**。

### (7)IRq mode

IRQ mode is the default mode to which an IRQ interrupt is taken.

IRQ模式是采用IRQ中断的默认模式。

一般中断模式也叫普通中断模式，用于处理一般的中断请求，通常在硬件产生中断信号之后自动进入该模式，该模式为特权模式，可以自由访问系统硬件资源。


### (8)Hyp mode

Hyp mode is the Non-secure PL2Imode, implemented as part of the Virtualization Extensions. Hypmode is entered on taking an exception from Non-secure state that must be taken to PL2

Hyp模式是作为虚拟化扩展的一部分实现的非安全PL2模式。Hyp模式在从非安全状态获取必须带到PL2的异常时进入

The Hypervisor Call exception and Hyp Trap exception are exceptions that are implemented aspart of the Virtualization Extensions, and that are always taken in Hyp mode.

Hypervisor Call异常和Hyp Trap异常是作为虚拟化扩展的一部分实现的异常，并且始终在Hyp模式下执行。

In a Non-secure PL1 mode, executing a HVC (Hypervisor Call) instruction generates a HypervisorCall exception.

在非安全PL1模式下，执行HVC(Hypervisor Call)指令会生成Hypervisor Call异常。

必须是非安全 + pl1

### (9)Monitor mode

Monitor mode is the mode to which a Secure Monitor Call exception is taken. In a PL1 mode,executing an SMC_(Secure Monitor Call) instruction generates a Secure Monitor Call exception.监视器

模式是采用安全监视器调用异常的模式。在PL1模式下，执行SMC(安全监视器调用)指令会生成安全监视器调用异常。

Monitor mode is a Secure mode, meaning it is always in the Secure state, regardless of the valueof the SCR(secure config register).NS bit. Software running in Monitor mode has access to boththe Secure and Non-secure copies of system registers. This means Monitor mode provides thenormal method of changing between the Secure and Non-secure security states.

监视器模式是一种安全模式，这意味着无论SCR.NS位的值如何，它都始终处于安全状态。在监视器模式下运行的软件可以访问系统寄存
器的安全和非安全副本。这意味着监视器模式提供了在安全和非安全安全状态之间更改的正常方法。

## ARM核(ARMv7) 的寄存器资源

![](http://cdn.pic.funpython.cn/image/202507272324504.png)

r0-r7 可以共享，切换模式还会在

FIQ 为啥快就是因为他拥有更多的寄存器资源

异常都有 SP LR

PC 也是所有寄存器共享，指令地址写在pc寄存器

CPSR 当前cpu 状态

SPSR 是为了保存CPSR

## 1.寄存器用途分析

RO-R10 用来存放用户的数据

R11(fp:frame-pointer)用来记录一个栈空间的开始地址

R12(ip: The Intra-Procedure-call scratch register) 用来临时存储sp

R13(sp:stack pointer) 栈指针寄存器 局部变量加栈

R14(lr:link register)在发生跳转的时候，用来保存PC寄存器的值 -> a函数调到b函数，跳之前要放到lr. 异常发生也是

R15(pc:program counter)用来存放CPU需要执行的指令所在内存的地址->取第二条

电话处理完，pc 要恢复 lr。


## 2.CPSR(Current Program Status Register)

![](http://cdn.pic.funpython.cn/image/202507272331574.png)

mode就是工作模式

![](http://cdn.pic.funpython.cn/image/202507272332463.png)

## 3.SPSR(Saved Program Status Register)

异常产生的时候，用来保存CPSR的值

每种模式都有自己的栈，会到自己的状态

# 4-ARM指令开发环境搭建

## 1-1Keil工程创建

![](http://cdn.pic.funpython.cn/image/202507282127804.png)

![](http://cdn.pic.funpython.cn/image/202507282132082.png)


```
.global _start

_start:
  mov r0,#10
  mov r1,#20
  mov r2,#30

stop:
	b stop
```

编译失败

```
Build started: Project: keil
*** Target 'Target_1' uses ARM-Compiler 'Default Compiler Version 5' which is not available.
*** Please review the installed ARM Compiler Versions:
   'Manage Project Items - Folders/Extensions' to manage ARM Compiler Versions.
   'Options for Target - Target' to select an ARM Compiler Version for the target.
*** Build aborted.
Build Time Elapsed:  00:00:07
```

![](http://cdn.pic.funpython.cn/image/202507282136139.png)


![](http://cdn.pic.funpython.cn/image/202507282136894.png)

语法格式

## 3.ARM指令集

ARM编译器介绍

![](http://cdn.pic.funpython.cn/image/202507282138624.png)


交叉编译工具链的命名规则为: `arch [-vendor][-os][-(gnu)eabi]`

- arch-体系架构，如ARM,MIPS等
- vendor -工具链提供商
- os-目标操作系统
- eabi-嵌入式应用二进制接口(Embedded Application Binary Interface)

交叉编译:在PC机上完成代码的编写与编译，在开发板上完成代码的运行

Embedded Application Binary Interface:嵌入式应用二进制接口指定了文件格式、数据类型、使用、堆积组织优化和在一个嵌入式软件中的参数的标准约定

根据对操作系统的支持与否，ARM GCC可分为支持和不支持操作系统，如arm-none-eabi:这个是没有操作系统的，自然不可能支持那些跟操作系统关系密切的函数，比如fork(2),它使用的是newlib这个专用于嵌入式系统的C库。 arm-none-linux-eabi:用于Linux的，使用Glibc

### 1、arm-none-eabi-gcc

Arm官方用于编译 ARM 架构的祼机系统(包括 ARM Linux 的 boot、kernel，不适用编译 Linux应用)，一般适合 ARM7、Cortex-M 和 Cortex-R 内核的芯片使用，所以不支持那些跟操作系统关系密切的函数，比如fork(2)，**他使用的是 newlib 这个专用于嵌入式系统的C库**。下载地址:https://developer.arm.com/downloads/-/gnu-rm

glibc 功能更强大，newlib针对嵌入式做了优化

![](http://cdn.pic.funpython.cn/image/202507282144772.png)

下载 gcc-arm-none-eabi-10.3-2021.10-win32.exe

### 2. arm-none-linux-gnueabi-gcc

主要用于基于ARM架构的Linux系统，可用于编译 ARM 架构的 u-boot、Linux内核、Linux应用等**使用Glibc库**，经过 Codesourcery 公司优化过推出的编译器。arm-none-linux-gnueabi基于GCC，arm-none-linux-gnueabi-xxx 交叉编译工具的浮点运算非常优秀。一般ARM9、ARM11、Cortex-A 内核，带有 Linux 操作系统的会用到。

### 3、arm-eabi-gcc

Android ARM 编译器,

### 4、armcc

ARM 公司推出的编译工具，功能和 arm-none-eabi 类似，可以编译裸机程序(u-boot、kernel)，但是不能编译 Linux 应用程序。armcc-般和ARM一起，KeiI MDK、ADS、RVDS和DS-5中的编译器都是armcc，所以 armcc 编译器都是收费的

支持的版本是v6的

### aarch64-linux-gnu-gcc

aarch64-linux-gnu-gcc是由 Linaro 公司基于 GCC 推出的的 ARM 交叉编译工具。可用于交叉编译**ARMv8 64** 位目标中的裸机程序、u-boot、Linux kernel、filesystem 和 App 应用程序。aarch64-linux-gnu-gcc **交叉编译器必须安装在 64 位主机上**，才能编译目标代码。

## 指定编译器

![](http://cdn.pic.funpython.cn/image/202507282156771.png)

![](http://cdn.pic.funpython.cn/image/202507282158976.png)

![](http://cdn.pic.funpython.cn/image/202507282159624.png)

目录下要有上图所示文件

## 开始反侦

![](http://cdn.pic.funpython.cn/image/202507282159635.png)

![](http://cdn.pic.funpython.cn/image/202507282201189.png)

勾上这两个红色按钮

![](http://cdn.pic.funpython.cn/image/202507282202403.png)

设置完之后要再次点击编译

![](http://cdn.pic.funpython.cn/image/202507282203682.png)

如果有两个箭头说明debug成功

![](http://cdn.pic.funpython.cn/image/202507282204374.png)


![](http://cdn.pic.funpython.cn/image/202507282205600.png)

是16进制的

```
stop:
	b stop
```

相当于死循环

# 5-ARM数据传送及运算指令

![](http://cdn.pic.funpython.cn/image/202507292232502.png)

表示指令执行的结果影响CPRSR的NZCV


`CPSR`（Current Program Status Register）是 ARM 架构中保存当前程序状态的重要寄存器之一，而 `NZCV` 是 `CPSR` 中的四个标志位，用于表示最近一次算术或逻辑操作的结果状态：

| 位 | 名称       | 含义说明                    |
| - | -------- | ----------------------- |
| N | Negative | 结果为负数时置 1（即结果的最高位为 1）   |
| Z | Zero     | 结果为 0 时置 1              |
| C | Carry    | 无符号进位/借位标志（如加法进位或减法无借位） |
| V | Overflow | 有符号溢出标志（正溢出或负溢出）        |

---

### 哪些指令会影响 NZCV？

大部分 **算术和逻辑运算指令**（如 `ADD`, `SUB`, `CMP`, `AND`, `ORR`, `MOV`, `RSB` 等），在后面加上 **`S` 后缀**，才会更新 `NZCV` 标志位。例如：

* `ADD r0, r1, r2` → 不影响标志位
* `ADDS r0, r1, r2` → 更新 NZCV

---

### 影响方式说明（以常见指令为例）：

* `ADDS r0, r1, r2`

  * N：结果最高位是否为 1
  * Z：结果是否为 0
  * C：是否产生进位
  * V：有符号溢出（两个正数加出负数，或两个负数加出正数）

* `SUBS r0, r1, r2`

  * C：是否没有借位（即 r1 ≥ r2）
  * V：有符号溢出（正减负或负减正时发生）

* `CMP r0, r1` 是 `SUBS` 的变体，不保存结果，但更新 NZCV

* `TST r0, r1` 是 `ANDS` 的变体，也只影响标志位

---

### NZCV 在实际中用在哪？

这些标志用于**条件执行**。例如：

```asm
CMP r0, #0
BEQ label   ; 如果 r0 == 0（Z == 1），跳转
BMI label   ; 如果 r0 为负数（N == 1），跳转
BVS label   ; 如果发生溢出（V == 1），跳转
```

---

### 你可以通过查看 CPSR 中的值判断指令执行状态，比如：

```asm
MRS r1, CPSR    ; 把 CPSR 的值读入 r1
```

* 然后你可以通过位操作查看第 31-28 位（即 NZCV）：

  * N：第 31 位
  * Z：第 30 位
  * C：第 29 位
  * V：第 28 位

---

如果你想继续深入（比如查看具体溢出/进位的计算原理），也可以告诉我你的应用场景（裸机调试？异常处理？汇编跳转？）我可以更有针对性地解释。


指令运行，需要两个操作数，第一擦作数必须是寄存器，第二操作数是立即数，寄存器，寄存器移位

## 1.立即数

一个常数，该常数必须对应8位位图，即一个8位的常数通过,循环右移偶数位得到该数，该数数为合法立即数。
在指令中表示方法:#数字，例如:#100

![](http://cdn.pic.funpython.cn/image/202507292238159.png)

循环右移就是把右边移除的数字又放回左边

![](http://cdn.pic.funpython.cn/image/202507292240522.png)

编译报错说不是合法立即数

### 快速判定是否是合法立即数:

- 首先将这个数转换为32bit的16进制形式，例如218=0xDA=0x000000DA
- 除零外，仅有一位数为合法立即数
- 除零外，仅有二位数，并且相邻(包括首尾，如0x1000000A)的为合法立即数
- 除零外，仅有三位数，并且相邻(包括中间有0相间，例如0x10800000,包括首尾相邻如:0x14000003)，这三位数中，最高位取值仅能为1、2、3，最低位取值仅能为4、8、C中间位0x0~0xF。这种组合的为合法立即数。

没问题！下面是**通俗易懂**的讲解，帮助你理解 ARM 汇编中 “**合法立即数**” 的概念，特别适合新手。

---

### 🎯 什么是“立即数”？

“立即数”就是写在汇编指令里的**常数值**，例如：

```asm
MOV r0, #1      ; 把数字 1 直接写入寄存器 r0
ADD r1, r1, #100 ; 把 100 加到 r1 上
```

这些 `#1`、`#100` 就是**立即数（Immediate）**。

---

### ⚠️ 为什么有“合法”这个说法？

ARM 汇编对立即数是**有限制**的，不是你想写多少就写多少。比如：

```asm
MOV r0, #0x12345678   ; ❌ 不合法！编译器会报错！
MOV r0, #0xFF         ; ✅ 合法！能写！
```

这就要说到：**ARM 架构规定了立即数必须能被编码成某种形式**。

---

### ✅ 什么才是合法立即数？（通俗版）

ARM（32位，比如 ARMv7）规定，立即数必须符合这个规则：

> 💡**一个 8 位的数（0 \~ 255）左旋转偶数位（0\~30之间）后得到的数**

也就是说，合法立即数 = **一个小数字**，**加上一个旋转**

---

### 🌰 举几个例子你就懂了！

| 立即数写法         | 合法？                    | 原因说明 |
| ------------- | ---------------------- | ---- |
| `#0xFF`       | ✅ 合法，8位内               |      |
| `#0x80000000` | ✅ 合法，因为 0x80 左旋转了 24 位 |      |
| `#0x1`        | ✅ 合法                   |      |
| `#0x10000001` | ❌ 不合法，无法通过旋转得到         |      |

---

### 🔧 判断方法（手动判断可以这么记）：

1. **是否小于等于 255**（8位以内）？ → 一定合法。
2. 如果不是，看看这个值能不能是某个 8 位数**循环左移偶数位**后变成的。

   * 例如：0x00008000 = 0x80 << 7 → 合法
   * 例如：0xF000000F → ❌ 不合法

---

### 📐 技术解释（进阶）

ARM 指令（如 `MOV`, `ADD`）的立即数字段长度是 12 位：

* 8 位数（imm8）
* 4 位旋转（rot \* 2）

实际值 = `imm8 ROR (rot * 2)`

例如：

```asm
MOV r0, #0x80000000  ; 实际是 0x80 ROR 8 = 0x80000000
```

---

### 💡 补充技巧：不合法立即数怎么办？

ARM 提供了解决办法：

* 使用 `LDR` 加载字面值：

  ```asm
  LDR r0, =0x12345678   ; 编译器自动放到文字池
  ```

* 编译器会自动选择写法：

  ```asm
  MOV     r0, #0xFF         ; 合法，直接用 MOV
  LDR     r0, =0x12345678   ; 不合法，用 LDR 加载常量
  ```

---

### ✅ 总结口诀：

```
合法立即数，小于 255；
否则必须，左旋转；
旋偶数位，0 到 30；
变出目标，才算对。
```

---

如果你有具体哪个立即数不确定合不合法，可以发给我，我帮你判断！或者我也可以给你一个 JS/Python 脚本，判断任意数是否合法立即数。

没问题！下面是**通俗易懂**的讲解，帮助你理解 ARM 汇编中 “**合法立即数**” 的概念，特别适合新手。

---

### 🎯 什么是“立即数”？

“立即数”就是写在汇编指令里的**常数值**，例如：

```asm
MOV r0, #1      ; 把数字 1 直接写入寄存器 r0
ADD r1, r1, #100 ; 把 100 加到 r1 上
```

这些 `#1`、`#100` 就是**立即数（Immediate）**。

---

### ⚠️ 为什么有“合法”这个说法？

ARM 汇编对立即数是**有限制**的，不是你想写多少就写多少。比如：

```asm
MOV r0, #0x12345678   ; ❌ 不合法！编译器会报错！
MOV r0, #0xFF         ; ✅ 合法！能写！
```

这就要说到：**ARM 架构规定了立即数必须能被编码成某种形式**。

---

### ✅ 什么才是合法立即数？（通俗版）

ARM（32位，比如 ARMv7）规定，立即数必须符合这个规则：

> 💡**一个 8 位的数（0 \~ 255）左旋转偶数位（0\~30之间）后得到的数**

也就是说，合法立即数 = **一个小数字**，**加上一个旋转**

---

### 🌰 举几个例子你就懂了！

| 立即数写法         | 合法？                    | 原因说明 |
| ------------- | ---------------------- | ---- |
| `#0xFF`       | ✅ 合法，8位内               |      |
| `#0x80000000` | ✅ 合法，因为 0x80 左旋转了 24 位 |      |
| `#0x1`        | ✅ 合法                   |      |
| `#0x10000001` | ❌ 不合法，无法通过旋转得到         |      |

---

### 🔧 判断方法（手动判断可以这么记）：

1. **是否小于等于 255**（8位以内）？ → 一定合法。
2. 如果不是，看看这个值能不能是某个 8 位数**循环左移偶数位**后变成的。

   * 例如：0x00008000 = 0x80 << 7 → 合法
   * 例如：0xF000000F → ❌ 不合法

---

### 📐 技术解释（进阶）

ARM 指令（如 `MOV`, `ADD`）的立即数字段长度是 12 位：

* 8 位数（imm8）
* 4 位旋转（rot \* 2）

实际值 = `imm8 ROR (rot * 2)`

例如：

```asm
MOV r0, #0x80000000  ; 实际是 0x80 ROR 8 = 0x80000000
```

---

### 💡 补充技巧：不合法立即数怎么办？

ARM 提供了解决办法：

* 使用 `LDR` 加载字面值：

  ```asm
  LDR r0, =0x12345678   ; 编译器自动放到文字池
  ```

* 编译器会自动选择写法：

  ```asm
  MOV     r0, #0xFF         ; 合法，直接用 MOV
  LDR     r0, =0x12345678   ; 不合法，用 LDR 加载常量
  ```

---

### ✅ 总结口诀：

```
合法立即数，小于 255；
否则必须，左旋转；
旋偶数位，0 到 30；
变出目标，才算对。
```

---

如果你有具体哪个立即数不确定合不合法，可以发给我，我帮你判断！或者我也可以给你一个 JS/Python 脚本，判断任意数是否合法立即数。


## 2.寄存器移位

将寄存器值读取之后，进行移位运算后，作为操作数2参与运算。支持的移位方式如下:

- LSL(Logical shift Left) 逻辑左移
- LSR(Logical shift Right)逻辑右移
- ASR(Arithmetic shift Right)算术右移

![](http://cdn.pic.funpython.cn/image/202507292250726.png)

算数左移 可以用逻辑左移代替

这个问题问得非常好！简单一句话先回答你：

> ✅ **在正数情况下，算术左移和逻辑左移的结果是一样的。**

所以，大多数情况下我们可以**用逻辑左移代替算术左移**，尤其是在 ARM 或 C 语言等平台/语言中。

---

## 一、📌 左移的两种类型

| 操作类型 | 名称                          | 符号位处理        | 填充内容  | 举例说明                           |
| ---- | --------------------------- | ------------ | ----- | ------------------------------ |
| 算术左移 | Arithmetic Shift Left (ASL) | 不考虑符号，像乘以 2ⁿ | 低位补 0 | `0b00001000 << 2 = 0b00100000` |
| 逻辑左移 | Logical Shift Left (LSL)    | 同上           | 低位补 0 | 一样                             |

🔹重点：**左移的时候，ASL 和 LSL 是一样的！**（都是低位补 0，高位溢出）

---

## 二、📌 为什么算术左移可以用逻辑左移代替？

### 1. ✅ 因为**它们行为一样**

不管是正数还是负数，只要做的是 **左移**，无论是 ASL 还是 LSL：

* **都是左移位数**
* **右边补 0**
* **不保留符号位**

示例：

```c
int8_t x = -4;   // 0b11111100
x << 1           // 0b11111000（-8）

int8_t y = 4;    // 0b00000100
y << 1           // 0b00001000（8）
```

你会发现，它只是二进制的位移，高位丢掉，低位补 0，**跟符号无关**。

---

### 2. ✅ 实际硬件中，**根本没有“算术左移”这种指令**

ARM / x86 / RISC-V 等 CPU 指令集中，只有：

* `LSL`（逻辑左移）
* `ASR`（算术右移）
* `LSR`（逻辑右移）

也就是说：

> **左移时，只有 LSL；ASL 是概念，不是实际指令。**

所以汇编写：

```asm
ASL r0, r1, #2   ; 实际等价于
LSL r0, r1, #2
```

---

### 3. ✅ C语言里 `<<` 也默认是逻辑左移

C 语言标准中，`a << n` 的行为是：

* **对无符号数**：就是逻辑左移
* **对有符号数**：只保证结果正确，不保证符号位保留（和逻辑左移一样）

所以实际编译结果是一样的（多数平台）。

---

## 三、📌 真正不同的是“右移”！

| 操作        | 行为     | 举例         |
| --------- | ------ | ---------- |
| 算术右移（ASR） | 高位补符号位 | -4 → -2    |
| 逻辑右移（LSR） | 高位补 0  | -4 → 很大的正数 |

右移时就不能混用了。

---

## ✅ 总结一句话：

> **左移时，算术左移和逻辑左移完全等价，可以互换 —— 因为它们都只管把位往左移，右边补 0，不保留符号位。**

---

如果你想，我可以给你写一个简单的图示或模拟代码，加深理解。你也可以发个例子给我，我们一起分析。

# TODO: 需要了解c语言位运算

非常棒，学习 C 语言的 **位运算符** 是掌握底层编程和高效控制硬件（嵌入式、驱动、图像处理等）非常关键的一步！

下面我会从 **基础语法 + 图解 + 实战例子** 手把手教你学会 C 语言中的所有位运算符。

---

## 🧠 一、C 语言中的位运算符一览

| 运算符  | 名称   | 作用                 | 示例            |     |     |
| ---- | ---- | ------------------ | ------------- | --- | --- |
| `&`  | 按位与  | 两位都为 1，结果才为 1      | `a & b`       |     |     |
| \`   | \`   | 按位或                | 有一位为 1，结果就为 1 | \`a | b\` |
| `^`  | 按位异或 | 不同为 1，相同为 0        | `a ^ b`       |     |     |
| `~`  | 按位取反 | 0 变 1，1 变 0（对每一位）  | `~a`          |     |     |
| `<<` | 左移   | 所有位左移，右侧补 0        | `a << n`      |     |     |
| `>>` | 右移   | 所有位右移，高位视情况补 0 或符号 | `a >> n`      |     |     |

---

## 📐 二、图解运算符作用（以 8 位为例）

```c
unsigned char a = 0b11001100;
unsigned char b = 0b10101010;
```

| 表达式      | 二进制结果      | 十进制        |     |
| -------- | ---------- | ---------- | --- |
| `a & b`  | `10001000` | 136        |     |
| \`a      | b\`        | `11101110` | 238 |
| `a ^ b`  | `01100110` | 102        |     |
| `~a`     | `00110011` | 51         |     |
| `a << 1` | `10011000` | 152        |     |
| `a >> 2` | `00110011` | 51         |     |

---

## 🧪 三、常用实战技巧

### 1. ✅ 判断某一位是否为 1

```c
int a = 0b10010000;
if (a & (1 << 4)) {
    printf("第 4 位是 1\n");
}
```

### 2. ✅ 置某一位为 1

```c
a |= (1 << 2);   // 把第 2 位设为 1
```

### 3. ✅ 清某一位为 0

```c
a &= ~(1 << 2);  // 把第 2 位设为 0
```

### 4. ✅ 取某一位的值（0 或 1）

```c
int bit = (a >> 3) & 1;  // 取第 3 位的值
```

### 5. ✅ 反转某一位

```c
a ^= (1 << 1);  // 第 1 位取反
```

---

## 🧩 四、左右移详细说明

### `a << n`：逻辑左移

* 所有位左移 n 位
* 右边补 0
* 有可能丢失高位（溢出）

```c
uint8_t a = 0b00001111;
a << 1  → 0b00011110
```

### `a >> n`：右移

* 对**无符号数**：逻辑右移（高位补 0）
* 对**有符号数**：算术右移（高位补符号位）

```c
int8_t a = -16;    // 二进制：11110000
a >> 2  → 11111100（还是负数）
```

---

## 🔍 五、拓展：位域与掩码操作

```c
#define BIT0  (1 << 0)
#define BIT1  (1 << 1)

unsigned char flags = 0;

// 设置第 1 位
flags |= BIT1;

// 检查第 0 位
if (flags & BIT0) { ... }
```

---

## 🧪 六、实战小练习题（初学者必做）

1. 判断整数中第 5 位是否是 1？
2. 如何清除一个数的第 2 位？
3. 如何把整数中最后一个 1 清除掉？（提示：`n & (n - 1)`）
4. 写一个函数 `count_bits(int n)`，统计二进制中 1 的个数。

想做题我可以出一组习题让你练手。

---

## ✅ 总结口诀（背下来很有用）

```
与清零，或置一，
异或翻转真有趣；
左移乘二很方便，
右移除二没浮点。
取反相当于补码，
位运操作别落下。
```

---

如果你有不懂的位运算式子，或者想要我出几道练习题帮你巩固，随时告诉我！要不要我出一套题供你练习？


## 1-2 ARM数据传送指令

### (1)MOV指令

格式:

mov 目标寄存器，操作数2
功能:将操作2的值赋值给目际寄存器

```asm
mov r0,#12       @r0=12
mov r1,r0        @r1=r0
mov r2,r1,lsl #2 @r2 = r1 << 2
```

`12 左移 2 位` 的意思是：

```
12 << 2
```

用二进制来理解更直观：

* 十进制 12 = 二进制 `1100`
* 左移 2 位：`1100` → `110000`
* `110000` 是二进制，换成十进制是：

```
1×2⁵ + 1×2⁴ + 0×2³ + 0×2² + 0×2¹ + 0×2⁰ = 32 + 16 = 48
```

### 答案：

```
12 左移 2 位 = 48
```

### 通用规则：

左移 `n` 位，相当于乘以 `2^n`：

```
12 << 2 = 12 × 2² = 12 × 4 = 48
```

### (2)MVN指令

格式: mvn 目标寄存器，操作数2
功能: 将操作2取反的值给目标寄存器

```asm
MVN ra,#@.// ro = ~0 => ro = oxffff,ffff
```

`MVN` 指令的全称是：

> **MoVe Not**

它是 ARM 汇编中的一条指令，用于将一个数按位取反后写入寄存器。

---

### 功能说明：

```asm
MVN Rd, Operand2
```

它的作用是：
将 `Operand2` 按位取反（bitwise NOT），结果写入目标寄存器 `Rd`。

### 举例：

```asm
MVN R0, #0x0F       ; R0 = ~0x0F = 0xFFFFFFF0
```

---

### 总结：

| 指令  | 全称       | 功能        |
| --- | -------- | --------- |
| MVN | Move Not | 按位取反后传送数据 |

如果你还有其他 ARM 指令想了解，也可以继续问我。

按位取反（Bitwise NOT）是一个逐位操作的运算，对应于逻辑中的 **非（NOT）**。
它会将每一位的 0 变成 1，1 变成 0。

---

### 举个例子（以 8 位二进制为例）

原始数（十进制）：

```
10
```

转换成二进制（8 位）：

```
00001010
```

按位取反后：

```
11110101
```

取反后的二进制是 `11110101`，换成十进制是：

```
= 0xF5 = 245（无符号）
```

但注意：
在 **带符号整数（如 ARM 中默认 32 位有符号）** 的场景下，结果是补码表示的：

* 10 的 32 位二进制是：`00000000 00000000 00000000 00001010`
* 取反后是：`11111111 11111111 11111111 11110101`
* 这代表的是 **-11**（即 `~10 = -11`）

---

### 总结一下：

| 类型    | 原始数 | 按位取反后的值 | 说明     |
| ----- | --- | ------- | ------ |
| 无符号整数 | 10  | 245     | 取反直接换算 |
| 有符号整数 | 10  | -11     | 补码表示   |

---

### 在 C 或汇编中：

```c
int a = 10;
int b = ~a;   // b == -11
```

---

### 应用场景

* 快速得到某个值的反码
* 位掩码操作（屏蔽特定位）
* 在嵌入式开发中经常用于寄存器配置

如果你还不熟补码或有符号/无符号的区别，我可以继续帮你讲解。

没问题，我来用**通俗易懂**的方式讲清楚：
**补码**、**有符号整数**、**无符号整数** 是理解按位运算的关键概念，尤其是在 C 和汇编语言中。

---

## 🧠 一、什么是有符号 / 无符号整数？

### 1. 无符号整数（`unsigned`）：

* 所有位都用来表示大小。
* 全部是 **非负数**（从 0 开始）。
* 例如 8 位无符号数的范围是：
  `0` 到 `255`（即 `2^8 - 1`）

---

### 2. 有符号整数（`signed`）：

* 最高位（最左边一位）用来表示**符号**：

  * `0` 表示正数
  * `1` 表示负数
* 剩下的位表示**数值的大小**
* 例如 8 位有符号整数的范围是：
  `-128` 到 `+127`

---

## 🧠 二、什么是补码？

计算机内部不直接存储 “负号”，而是用一种叫做 **补码** 的方式表示负数。这样做的好处是：加减乘除都可以统一用一个运算电路完成！

---

### 🔢 举例（以 8 位为例）：

#### 正数很简单：

| 十进制 | 二进制      |
| --- | -------- |
| 5   | 00000101 |

#### 负数（比如 -5）怎么办？ ➡️ 计算它的“补码”

计算步骤：

1. 求 5 的二进制：`00000101`
2. 取反：`11111010`
3. 加 1：`11111011`（这就是 -5 的补码）

所以：

```
-5 的补码 = 11111011
```

---

## ✅ 总结：有符号数的补码规则

| 十进制  | 二进制（8位补码）  |
| ---- | ---------- |
| 5    | `00000101` |
| -5   | `11111011` |
| 0    | `00000000` |
| -1   | `11111111` |
| -128 | `10000000` |
| +127 | `01111111` |

---

## 🧪 示例：为什么 `~10 = -11`？

原数 10（有符号，32 位）：

```
00000000 00000000 00000000 00001010
```

取反（按位 NOT）：

```
11111111 11111111 11111111 11110101  // 即 -11 的补码形式
```

它正好是 -11！✅

---

## 📌 总结一句话：

* **补码**是计算机中用来表示负数的一种方式，能让加法/减法更统一。
* **有符号数**用补码来表示负数，**无符号数**就直接从 0 数到最大。
* 按位取反（`~`）在有符号数中可能会得到负值，是因为用了补码表示法。

---

如果你想试试自己算补码，或用 C 写代码看看效果，我可以陪你一起做几道题。是否继续？

这是一个**非常好的问题**！你问的是：

> 👉 如何快速看出 `11111111 11111111 11111111 11110101` 是 -11？

---

## ✅ 这是负数的补码，快速还原的方法如下：

---

### 🔁 一步一步教你从补码还原成十进制负数：

> 补码 → 原码 → 十进制

---

## ✍️ 步骤一：判断是不是负数

* 看最高位（最左边那一位）
* 如果是 `1`，那它是一个**负数补码**
* 我们这个数是：

  ```
  11111111 11111111 11111111 11110101
  ↑
  这是 1，说明是负数
  ```

---

## ✍️ 步骤二：取反再加 1（还原出它的“正数部分”）

### 原始补码：

```
11111111 11111111 11111111 11110101
```

### 第一步：按位取反

```
00000000 00000000 00000000 00001010
```

### 第二步：加 1

```
00000000 00000000 00000000 00001011
```

即：

```
二进制 1011 = 十进制 11
```

---

## ✍️ 步骤三：加负号

* 刚才我们还原的是“绝对值”
* 补码的符号是负 → 所以最后是 **-11**

---

## ✅ 快速技巧总结：

| 补码（二进制）                                                | 快速识别方法                      |
| ------------------------------------------------------ | --------------------------- |
| `最高位是 1`                                               | 是负数                         |
| 取反后加 1，得正数部分                                           | 然后加个负号                      |
| `11111111 11111111 11111111 11110101` → `~` → `1010`+1 | 得到 `1011`（即 11），最后加负号：`-11` |

---

## 💡进阶小技巧（背下来很有用）

| 补码（十六进制）     | 十进制 |
| ------------ | --- |
| `0xFFFFFFFF` | -1  |
| `0xFFFFFFFE` | -2  |
| `0xFFFFFFF5` | -11 |

只要你看到一串 `F` 开头的数，就八成是个负数补码，倒推一下即可。

---

如果你想练习几个补码反推，我可以出几道小题练一练？是否继续？

# (3)LDR指令

格式:LDR 目标寄存器,= 数据
功能:完成任意的数据传送到目标寄存器注意:数据前面不能加#，因为此时数据不按立即数来处理

```
LDR ro,=0x12345678 //r0=0x12345678
```

`LDR` 指令是 ARM 汇编中的一个非常常用的指令。

---

## LDR 指令全称

**Load Register**（加载寄存器）

---

## 功能

* 从内存读取数据，加载到寄存器中。
* 简单来说，就是“从内存里拿数据放进寄存器”。

---

## 基本格式

```asm
LDR Rd, [Rn, #offset]
```

* `Rd`：目标寄存器，加载后的数据放这里
* `[Rn, #offset]`：内存地址，由寄存器 `Rn` 加上偏移量 `offset` 组成

---

## 举例说明

```asm
LDR R0, [R1, #4]
```

意思是：

* 用寄存器 R1 里的值作为内存地址基准
* 偏移 4 个字节后，读取这个地址里的数据
* 把数据加载到寄存器 R0

---

## 其他常见用法

* 直接加载立即数到寄存器（伪指令）

```asm
LDR R0, =0x12345678
```

这个伪指令会把立即数 `0x12345678` 加载到 R0，底层是加载内存里的一个字（通常编译器帮你处理）。

---

## 总结

| 指令  | 全称            | 功能          |
| --- | ------------- | ----------- |
| LDR | Load Register | 从内存加载数据到寄存器 |

---

需要我帮你讲解它和 `STR`（存储指令）的区别，或者给你更多例子吗？

![](http://cdn.pic.funpython.cn/image/202507292320214.png)

合法立即数会翻译为MOV

![](http://cdn.pic.funpython.cn/image/202507292322113.png)

从内存中读取的

# 2.数据计算指令

## (1)ADD指令

格式:add 目标寄存器，操作数1，操作数2

功能:将操作数1加上操作数2的结果给目标寄存器

```
add ro,r1,#3 // r0=r1+3
add ro,r1,r2  // r0=r1+r2
add ro,r1,r2,lsl #2 //r0 =r1 +(r2 <<2)
```

LSL 指令是 ARM 架构中常见的一条逻辑左移指令（Logical Shift Left）

ASL（Arithmetic Shift Left）其实是 LSL 的别名，两者效果一样，ARM 通常使用 LSL

```asm
	mov r0,#1
	mov r1,#2
	add r2,r0,r1
	add r3,r2,r1,lsl #1 @r3 = r2 + (r1<<1)

  不能写成 #2 lsl #1 因为只能是寄存器移位
```

左移是后面补0，等于乘以2的几次方

r1 值不会变化，是拷贝出来然后参与计算的

```
r0 =1
r1 =2
r2 = r0+r1 = 3
r3 = r2 + (r1 << 1) = 3 + 2 *2 = 7
```



## (2)SUB指令

格式:sub 目标寄存器，操作数1，操作2

功能:将操作数1减去操作数2的结果给目标寄存器

```
sub ro,r1,#3         // r0=r1-3
sub ro,r1,r2         // ro=r1-r2
sub ro,r1,r2,lsl #2  // ro =r1 -(r2 << 2)
```

![](http://cdn.pic.funpython.cn/image/202507302227149.png)

-1 然后以补码形式显示

subs 负数影响 CPSR 的 N位

![](http://cdn.pic.funpython.cn/image/202507302228138.png)

### subs

`SUB` 和 `SUBS` 都是 ARM 汇编里的减法指令，区别在于 **是否更新条件标志（CPSR 里的 N、Z、C、V 标志位）**。

---

## 1. `SUB` — 不更新条件标志

```asm
SUB R0, R1, R2
```

* 执行 `R0 = R1 - R2`
* **不修改** CPSR 状态寄存器里的条件标志位
* 适合你只想计算结果，不需要后续条件判断的场景

---

## 2. `SUBS` — 更新条件标志

```asm
SUBS R0, R1, R2
```

* 执行 `R0 = R1 - R2`
* **更新 CPSR 里的 N（负）、Z（零）、C（进位）、V（溢出）标志**
* 方便后续根据减法结果做条件跳转、判断等操作

---

## 为什么设计带 `S` 的指令？

带 `S` 后缀的指令表示 “**Set flags**”，即“设置状态标志”。

* 在汇编里，条件跳转通常依赖于状态寄存器（CPSR）里的标志位，比如：

  * `BEQ`（等于时跳转，检查 Z=1）
  * `BNE`（不等时跳转，检查 Z=0）
  * `BMI`（负数时跳转，检查 N=1）
* 如果你执行减法后需要马上判断结果，必须先更新这些标志位。
* 设计有 `S` 后缀的指令，可以让你灵活选择是否更新标志，节省不必要的状态寄存器写入，提高效率。

---

### 举例说明

```asm
SUB R0, R1, R2      ; R0 = R1 - R2，不更新标志
BNE label           ; 这里的跳转条件是上次指令更新的标志，与此 SUB 无关

SUBS R0, R1, R2     ; R0 = R1 - R2，更新标志
BNE label           ; 根据刚才 SUBS 结果判断是否跳转
```

---

总结：

| 指令   | 功能         | 是否更新状态标志 |
| ---- | ---------- | -------- |
| SUB  | 减法         | 否        |
| SUBS | 减法 + 更新标志位 | 是        |

---

如果你想，我可以帮你写一段示例代码演示带 `S` 和不带 `S` 的区别！






## (3)MUL指令

SUB 指令全称：Subtract，意思是“减去”。

MUL 指令全称：Multiply，意思是“乘以”。

格式:mul 目标寄存器，操作1，操作2

功能:将操作数1乘以操作数2的结果存放在目标寄存器

注意:
操车数1和操作2必须都是寄存器,并且操作1的寄存器编号不能和目标寄存器一样


```

```

你说的这个限制，确实是 ARM 架构中 `MUL` 指令的一个典型特点，具体原因主要和它的指令格式和硬件实现有关。

---

## 1. 操作数必须是寄存器

ARM 的 `MUL` 指令只支持两个寄存器相乘，**不支持立即数（immediate）直接参与乘法运算**。这是因为：

* ARM 指令集设计中，`MUL` 指令的编码格式只预留了寄存器字段，不包含立即数操作数编码。
* 乘法器硬件电路设计主要面向寄存器间乘法，立即数乘法一般先通过 `MOV` 指令加载到寄存器，再执行乘法。

所以如果你要用立即数乘法，必须先用 `MOV` 指令将立即数放到寄存器，再用 `MUL`。

---

## 2. 操作数1（第一个源寄存器）不能和目标寄存器相同

ARM `MUL` 指令格式（简化版）：

```
MUL Rd, Rm, Rs
```

* `Rd`: 目标寄存器（结果）
* `Rm`: 第一个源寄存器
* `Rs`: 第二个源寄存器

**限制是**：`Rd` 和 `Rm` 不能是同一个寄存器，但 `Rd` 可以和 `Rs` 相同。

### 为什么有这个限制？

* ARM 的 `MUL` 指令硬件实现是用 `Rm` 的值乘以 `Rs`，结果写到 `Rd`。
* 硬件内部设计上，它会直接覆盖 `Rd`，而如果 `Rd` 和 `Rm` 是同一个寄存器，寄存器的值会在乘法过程中被覆盖，导致乘数被破坏，运算结果不正确。
* 这是一种硬件级别对寄存器读写的同步限制，避免数据冲突和不确定的结果。

---

## 3. 例外与其他架构

* 有些 ARM 变体（例如 Thumb-2 指令集）可能放宽或支持更灵活的写法，但经典 ARM 指令集遵守这个限制。
* 其他架构（如 x86）乘法指令允许目标寄存器和源寄存器相同，但它们的硬件设计和指令编码不同。

---

## 4. 使用建议

如果你想要乘法的结果放在和 `Rm` 相同的寄存器，可以先用 `MOV` 复制一下：

想实现效果: R3 = R3 * R2

```asm
MOV R4, R3        ; 中间寄存器保存 R3 的值
MUL R3, R4, R2    ; Rd = R3，Rm = R4，Rs = R2（合法）
```

---

如果你需要，我可以帮你写一个具体示例或者更详细的解读。你觉得怎么样？

好问题！为什么 ARM `MUL` 指令里允许 **第二个操作数（Rs）和目标寄存器（Rd）相同**，但不允许 **第一个操作数（Rm）和目标寄存器（Rd）相同**，这其实和指令的硬件数据通路设计有关。

---

## 先回顾指令格式

```asm
MUL Rd, Rm, Rs
```

* `Rd` 是乘法结果存放寄存器
* `Rm` 是第一个乘数寄存器（乘数1）
* `Rs` 是第二个乘数寄存器（乘数2）

---

## 1. 为什么不允许 `Rd == Rm`？

* `Rm` 的值需要在乘法计算中 **完整且稳定地保持**，作为乘数的输入。
* 如果 `Rd` 和 `Rm` 是同一个寄存器，结果写回的时候会覆盖掉乘数（`Rm`），导致计算过程中的乘数值被破坏。
* 硬件实现上，乘法单元一边读 `Rm`，一边又写回 `Rd`，如果是同一个寄存器就会读写冲突，产生错误结果。

---

## 2. 为什么允许 `Rd == Rs`？

* ARM 处理器的乘法硬件设计中，读取第二个乘数（`Rs`）的时序和逻辑和第一个乘数（`Rm`）是分开的。
* 写回结果给 `Rd`（如果等于 `Rs`），不会干扰 `Rs` 的值读取，因为：

  * 乘法单元先 **完整读取** `Rs` 的值，再把结果写回 `Rd`。
  * 也就是说，读取 `Rs` 的时钟周期和写回 `Rd` 是错开的，避免了冲突。
* 硬件允许先把第二操作数的值缓存或者锁存，再写回 `Rd`，所以不会破坏 `Rs` 的原值。

---

## 总结

| 情况         | 允许？ | 原因                  |
| ---------- | --- | ------------------- |
| `Rd == Rm` | 不允许 | 写回会破坏第一个乘数的值，读写冲突   |
| `Rd == Rs` | 允许  | 先读取 Rs 的值再写回，时序避免冲突 |

---

如果你对 ARM 指令流水线、寄存器读写时序感兴趣，我可以帮你详细讲讲硬件执行过程！你想了解吗？

![](http://cdn.pic.funpython.cn/image/202507302237495.png)


## (4)练习

```
练习1:
(2<<2)-5+0x12345678,计算的结果存放在r0
练习2:
25-3*5+6 最终的计算结果存放在r0中
```

我的答案:

```
mov r1,#3
mov r2,#5
MUL r2,r1,r2
mov r1,#25 
SUB r2,r1,r2
ADD r0,r2,#6


mov r1, #3        ; r1 = 3
mov r2, #5        ; r2 = 5
MUL r2, r1, r2    ; r2 = r1 * r2 = 3 * 5 = 15
mov r1, #25       ; r1 = 25（重载 r1，之前的值已用完）
SUB r2, r1, r2    ; r2 = 25 - 15 = 10
ADD r0, r2, #6    ; r0 = 10 + 6 = 16

mov r0, #3         
mov r1, #5         
mul r1, r0, r1  // 这里顺序不能乱，因为不可以目标和操作数1相同  
mov r0, #25        
sub r0, r0, r1     
add r0, r0, #6 


```

我的答案:

```asm
	mov r1,#2
	mov r2,r1,lsl #2
	sub r3,r2,#5
	ldr r4,=0x12345678 @注意这里有一个等号
	add r0,r4,r3
  

  mov r0, #2
mov r1,r0,lsl #2
sub r0,r1,#5
ldr r1,=0x12345678
add r0,r1,r0
```

优化

```
mov r1,#2
mov r2,r1,lsl #2
SUB r1,r2,#5
ldr r2,=0x12345678
add r0,r2,r1
```

这是一个很细节但重要的问题，尤其在 ARM 汇编中容易混淆。

---

## ✅ 简短回答：

| 指令                   | 类型     | 实际效果                          |
| -------------------- | ------ | ----------------------------- |
| `MOV R2, R1, LSL #2` | 数据处理指令 | 把 `R1` 左移 2 位，结果存入 `R2`       |
| `LSL R2, R1, #2`     | 伪指令    | 汇编器自动转换为 `MOV R2, R1, LSL #2` |

---

## 🔍 详细解释

### 1️⃣ `MOV R2, R1, LSL #2` 是一条真实的 ARM 指令

* 本质上是把 `R1` 的值逻辑左移 2 位，结果放到 `R2`
* **这是 ARM 架构中支持的一种带“移位操作数”的 `MOV` 指令**
* 语法格式：

  ```asm
  MOV Rd, Rm, <shift_type> #shift_amount
  ```

  即：

  ```asm
  MOV R2, R1, LSL #2
  ```

  表示：`R2 = R1 << 2`（逻辑左移）

---

### 2️⃣ `LSL R2, R1, #2` 是一条 **伪指令（pseudo-instruction）**

* 汇编器在预处理时会把它翻译为：

  ```asm
  MOV R2, R1, LSL #2
  ```

* 所以 `LSL` 在这里不是一个真实存在的机器码指令，而是 **语法糖**

* 和很多 ARM 伪指令一样，写起来直观，但最终都是被翻译成真实的 `MOV`、`ADD` 等指令

---

## ✅ 总结

| 指令形式                 | 是否真实指令   | 被翻译为                 |
| -------------------- | -------- | -------------------- |
| `MOV R2, R1, LSL #2` | ✅ 是      | 自身                   |
| `LSL R2, R1, #2`     | ❌ 否（伪指令） | `MOV R2, R1, LSL #2` |

所以它们**行为完全一样**，只是写法不同。

---

## ✅ 补充：其他常见伪指令还有哪些？

| 伪指令                 | 实际翻译为            |
| ------------------- | ---------------- |
| `ADR`               | `ADD` 或 `SUB`    |
| `LDR Rn, =const`    | 加载常量到文字池         |
| `CMP Rn, #0`        | `TST` 或 `SUBS`   |
| `LSR`, `ASR`, `ROR` | 通常也是 `MOV` 加移位修饰 |

---

如你希望我帮你查看某段汇编代码是伪指令还是实际机器指令，也可以贴上来。是否在写 ARM 裸机程序？


## 除法

ARM 早期指令集确实没有内建硬件除法指令，主要原因有几个：

---

## 1. 设计复杂度和硬件成本

* **乘法和除法**硬件实现复杂度差别很大。
* 乘法器可以用快速乘法器设计完成，效率较高。
* 除法器需要复杂的迭代运算或特定硬件（如除法单元），面积和功耗成本高。
* 早期 ARM 设计追求低成本、低功耗，舍弃了硬件除法。

---

## 2. 早期 ARM 应用场景限制

* ARM 最初用于嵌入式、低功耗设备，对除法需求不高或可用软件模拟解决。
* 软件除法（用移位、减法循环实现）对许多嵌入式应用性能是够用的。

---

## 3. 指令集简洁原则

* RISC 设计哲学：**指令集保持简单，常用操作硬件支持，复杂操作用软件实现。**
* 早期 ARM 遵循这个理念，减少指令集复杂度。

---

## 4. 后期 ARM 版本增加除法

* 从 ARMv7-M（Cortex-M3/M4）开始，加入了硬件除法指令 `SDIV`（有符号除法）、`UDIV`（无符号除法）。
* Cortex-A 系列现代 ARM 核也支持除法指令。
* 早期版本只能通过库函数或软件模拟实现除法。

---

## 总结

| 版本          | 是否有硬件除法指令       |
| ----------- | --------------- |
| ARMv4/v5/v6 | 无               |
| ARMv7-M 及以后 | 有 `SDIV`、`UDIV` |
| 现代 ARM 体系   | 普遍支持除法指令        |

---

如果你需要，我可以帮你写一个基于移位和减法的**软件除法算法汇编示例**，适用于早期 ARM 平台。你需要吗？















非常好，学习 ARM 汇编是理解底层驱动开发、BootLoader、异常处理和系统调用的关键步骤。下面我将带你掌握 ARM 核心常用的汇编指令及其含义、用法和场景。

---

## 🧠 一、ARM 汇编语言概述

ARM 汇编语言是面向 ARM 指令集架构（ISA）的一种低级语言，使用**助记符**来代替二进制机器码。
常用于：

* 编写启动代码（如 `start.S`）
* 实现中断/异常处理函数
* 操作寄存器、控制跳转
* 嵌入 C 中的 `__asm__` 代码做性能优化或硬件控制

---

## 📦 二、ARM 常用汇编指令分类

### ✅ 数据处理类（算术与逻辑运算）

| 指令    | 含义   | 示例                  | 说明                 |      |
| ----- | ---- | ------------------- | ------------------ | ---- |
| `MOV` | 赋值   | `MOV R0, #1`        | 把立即数1写入R0          |      |
| `ADD` | 加法   | `ADD R1, R2, R3`    | R1 = R2 + R3       |      |
| `SUB` | 减法   | `SUB R1, R2, #5`    | R1 = R2 - 5        |      |
| `RSB` | 反转减法 | `RSB R1, R2, #0`    | R1 = 0 - R2（取反）    |      |
| `MUL` | 乘法   | `MUL R0, R1, R2`    | R0 = R1 × R2       |      |
| `AND` | 位与   | `AND R0, R1, R2`    | R0 = R1 & R2       |      |
| `ORR` | 位或   | `ORR R0, R1, #0x80` | R0 = R1            | 0x80 |
| `EOR` | 异或   | `EOR R0, R1, R2`    | R0 = R1 ^ R2       |      |
| `BIC` | 清除位  | `BIC R0, R1, #0xFF` | R0 = R1 & (\~0xFF) |      |
| `CMP` | 比较   | `CMP R0, #10`       | 设置标志位，不写入 R0       |      |
| `TST` | 位测试  | `TST R0, #0x01`     | 类似 AND + 不写结果      |      |

---

### ✅ 数据传输类（访问内存）

| 指令     | 含义       | 示例                    | 说明              |
| ------ | -------- | --------------------- | --------------- |
| `LDR`  | 加载数据     | `LDR R0, [R1]`        | R0 = \*(R1)     |
| `STR`  | 存储数据     | `STR R0, [R1, #4]`    | \*(R1 + 4) = R0 |
| `LDRB` | 加载字节     | `LDRB R0, [R1]`       | 只读 8 位          |
| `STRB` | 存储字节     | `STRB R0, [R1]`       | 只写 8 位          |
| `LDR`  | 加载立即数伪指令 | `LDR R0, =0x12345678` | 加载一个地址/常数       |

---

### ✅ 控制跳转类

| 指令    | 含义          | 示例        | 说明               |
| ----- | ----------- | --------- | ---------------- |
| `B`   | 跳转          | `B loop`  | 跳转到 loop 标签      |
| `BL`  | 跳转并链接       | `BL func` | 跳转到 func，LR=返回地址 |
| `BX`  | 跳转到寄存器      | `BX LR`   | 跳转回 LR 寄存器地址     |
| `BLX` | 跳转链接 + 切换状态 | `BLX R0`  | ARM/Thumb 状态切换调用 |

---

### ✅ 条件执行（ARM 的特性）

ARM 大多数指令都可以加条件后缀（执行条件由 CPSR 的标志位控制）：

| 条件码  | 含义   | 触发条件      |
| ---- | ---- | --------- |
| `EQ` | 等于   | Z=1       |
| `NE` | 不等   | Z=0       |
| `GT` | 大于   | Z=0 且 N=V |
| `LT` | 小于   | N≠V       |
| `GE` | 大于等于 | N=V       |
| `LE` | 小于等于 | Z=1 或 N≠V |
| `AL` | 总是执行 | Always    |

> 示例：`ADDNE R0, R0, #1` → 当不相等时加 1。

---

### ✅ 栈操作指令

| 指令      | 含义    | 示例                   | 说明              |
| ------- | ----- | -------------------- | --------------- |
| `PUSH`  | 入栈    | `PUSH {R4-R7, LR}`   | 保存寄存器到栈         |
| `POP`   | 出栈    | `POP {R4-R7, PC}`    | 恢复寄存器；PC 出栈实现返回 |
| `STMFD` | 全递减存储 | `STMFD SP!, {R0-R3}` | 常用于函数入口保存现场     |
| `LDMFD` | 全递减加载 | `LDMFD SP!, {R0-R3}` | 常用于函数返回恢复现场     |

---

### ✅ 状态与异常指令

| 指令    | 含义        | 示例                  | 说明               |
| ----- | --------- | ------------------- | ---------------- |
| `SVC` | 软中断（系统调用） | `SVC #0`            | 进入 Supervisor 模式 |
| `MRS` | 读状态寄存器    | `MRS R0, CPSR`      | 读取当前程序状态寄存器      |
| `MSR` | 写状态寄存器    | `MSR CPSR_c, #0x1F` | 改变处理器模式          |
| `NOP` | 空指令       | `NOP`               | 占位，无任何作用         |

---

## 🚦 三、常见场景示例

### 1. 简单函数调用

```assembly
add:
    ADD R0, R0, R1    ; R0 = R0 + R1
    BX LR             ; 返回
```

### 2. 参数传递与返回（与 C 函数协作）

```c
int add(int a, int b);  // a → R0, b → R1, 返回值 → R0
```

对应汇编逻辑：

```assembly
ADD R0, R0, R1
BX  LR
```

### 3. 函数调用保存现场

```assembly
func:
    PUSH {R4-R7, LR}     ; 保存调用现场
    ...                  ; 执行任务
    POP  {R4-R7, PC}     ; 恢复 + 返回
```

---

## 🔚 四、ARM 汇编格式简要规则

```assembly
<指令> <目的寄存器>, <源1>, <源2 or #立即数>
```

> 例：`ADD R0, R1, #5` → R0 = R1 + 5

---

## ✅ 小结口诀（助记）

```
MOV赋值常见，ADD SUB 算数连；
AND OR 位操作，CMP 比较设条件；
LDR STR 操内存，B/BL 跳转瞬；
PUSH POP 栈中转，SVC 异常入内核；
寄存器灵活选，状态控制靠 CPSR。
```

---

是否需要我继续帮你写一个“从启动代码到 main 的裸机启动流程汇编 demo”？它结合了上面大部分指令。或者你有具体汇编段落想要讲解？

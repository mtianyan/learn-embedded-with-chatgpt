ATPCS（**ARM-Thumb Procedure Call Standard**）是 ARM 官方制定的一套 **函数调用约定**，用于规定函数调用过程中参数的传递方式、返回值如何返回、寄存器使用规则、栈帧布局等。这是嵌入式开发者必须掌握的关键基础之一。

---

## 📌 一、ATPCS的作用

ATPCS 标准目的是：

* 保证不同模块（C 与汇编、不同编译器生成代码）间函数调用的兼容性。
* 提高函数调用效率。
* 定义好寄存器、堆栈、参数传递规则。

---

## 📚 二、寄存器分类

| 寄存器名   | 含义                     | ATPCS中用途        |
| ------ | ---------------------- | --------------- |
| R0-R3  | 通用寄存器                  | 用于传递前4个参数 & 返回值 |
| R4-R11 | 被调用者保存寄存器（callee-save） | 被调用函数需保存和恢复     |
| R12    | 临时寄存器（IP）              | 用作中间过程寄存器       |
| R13    | 栈指针（SP）                | 指向当前栈顶          |
| R14    | 链接寄存器（LR）              | 保存返回地址          |
| R15    | 程序计数器（PC）              | 指向下一条指令         |

---

## 🎯 三、参数传递规则（函数调用）

* **R0-R3**：传递前 **4 个参数**（从左到右依次放入）
* **R4+ 参数**：如果超过4个参数，剩下的参数通过**栈**传递（入栈）
* **结构体或复杂类型**：有时通过指针传递
* **浮点参数**：如果启用了VFP/NEON协处理器，则用浮点寄存器（如D0\~D7）传递

### 示例：

```c
int add(int a, int b, int c, int d, int e);
```

* R0: a
* R1: b
* R2: c
* R3: d
* [SP+0]: e（通过栈传递）

---

## 🔁 四、返回值规则

* **R0**：返回 int、char、指针等小型类型
* **R0 + R1**：返回 64 位整型（如 long long）
* **结构体返回值**：可能通过 R0 传递指针返回

---

## 🧠 五、C 与汇编对照分析

### C语言函数

```c
int sum(int a, int b) {
    return a + b;
}
```

### 汇编表示（伪代码）

```asm
sum:
    ADD r0, r0, r1   ; R0 = R0 + R1
    BX  lr           ; 返回到调用者
```

调用者：

```asm
MOV r0, #3
MOV r1, #4
BL  sum        ; 调用函数
; 返回值在R0中
```

---

## 🧩 六、栈帧结构

函数调用过程中，函数常会构建**栈帧**保存上下文信息：

```txt
+----------------+
| 参数5 及以上    | ← SP 入栈参数
| 返回地址(LR)   |
| 上一个FP       | ← FP（R7）
| 局部变量/保存寄存器 |
+----------------+
```

标准栈帧构建：

```asm
PUSH {fp, lr}
ADD  fp, sp, #4      ; 建立新的栈帧
...
POP  {fp, pc}        ; 恢复上下文并返回
```

---

## ✅ 七、ATPCS 的重要性总结

| 内容      | 描述            |
| ------- | ------------- |
| 参数传递    | R0-R3，超过入栈    |
| 返回值     | R0，复杂情况 R0+R1 |
| 寄存器使用规则 | 哪些函数可改、哪些要保存  |
| 栈帧构建规范  | 保证可调试性和嵌套调用   |

---

如果你接下来的课程涉及 **裸机开发、汇编调试、分析编译器输出**，熟悉 ATPCS 将让你如虎添翼。

需要我给你几个练习题或真题分析吗？

好的，我们通过 **C 语言与汇编函数调用对比**，逐步来理解 ATPCS 标准的实际运作方式。下面我将从参数传递、返回值、栈帧构建等多个方面进行讲解，并配以对比示例。

---

## 🧩 一、函数参数传递对比

### C 代码示例

```c
int add(int a, int b, int c, int d, int e) {
    return a + b + c + d + e;
}
```

根据 ATPCS 规则：

* `a` → R0
* `b` → R1
* `c` → R2
* `d` → R3
* `e` → \[SP+0]（第5个参数，入栈）

---

### 汇编对应

```asm
add:
    PUSH {lr}           ; 保存返回地址
    LDR r4, [sp, #0]     ; e 是第5个参数，从栈读取
    ADD r0, r0, r1       ; r0 = a + b
    ADD r0, r0, r2       ; r0 = r0 + c
    ADD r0, r0, r3       ; r0 = r0 + d
    ADD r0, r0, r4       ; r0 = r0 + e
    POP {pc}             ; 返回
```

---

## 🔁 二、返回值传递

### C 函数

```c
int square(int x) {
    return x * x;
}
```

### 汇编表示

```asm
square:
    MUL r0, r0, r0   ; r0 = r0 * r0
    BX lr            ; 返回
```

> 返回值存在 R0 中。

---

## 🧠 三、函数调用与返回过程

### C 主调函数

```c
int main() {
    int r = square(5);
}
```

### 汇编主调方（调用方）

```asm
MOV r0, #5      ; 准备参数
BL  square      ; 调用函数
; 返回值已在 R0
STR r0, [sp, #0] ; 存到栈中
```

---

## 📦 四、栈帧构建与销毁

### C 函数（含局部变量）

```c
int sub(int a, int b) {
    int tmp = a - b;
    return tmp * 2;
}
```

### 汇编实现（含标准栈帧）

```asm
sub:
    PUSH {fp, lr}       ; 保存上一个FP与返回地址
    ADD fp, sp, #4      ; 建立新的栈帧

    SUB r2, r0, r1      ; tmp = a - b
    MOV r0, r2
    ADD r0, r0, r2      ; r0 = tmp * 2

    POP {fp, pc}        ; 恢复FP与返回
```

> 使用标准栈帧（`fp`指向上一个栈帧），方便调试器追踪调用关系。

---

## 📋 五、被调用者保存寄存器 vs 可破坏寄存器

### 被调用者（callee-saved）寄存器：`R4-R11`

> 如果函数用了这些寄存器，必须**保存再恢复**。

### 可破坏（caller-saved）寄存器：`R0-R3`, `R12`

```asm
PUSH {r4, r5}
...
; 使用 r4, r5 做计算
...
POP {r4, r5}
```

---

## ✅ 六、总结对比表

| 项目        | C语言       | 汇编实现                               | 备注 |
| --------- | --------- | ---------------------------------- | -- |
| 参数传递      | 函数参数      | R0-R3，超过部分入栈                       |    |
| 返回值传递     | return 语句 | 返回值存在 R0 中                         |    |
| 函数调用      | 直接调用函数名   | `BL func_name`                     |    |
| 函数返回      | 自动返回      | `BX lr` 或 `POP {pc}`               |    |
| 局部变量/临时变量 | 函数内部定义    | 用寄存器或栈                             |    |
| 栈帧维护      | 编译器自动管理   | `PUSH {fp, lr}` / `ADD fp, sp, #4` |    |

---

## 🧪 七、练习建议

你可以用如下方式练习：

1. 写一个带多个参数和局部变量的 C 函数。
2. 编译为汇编（用 `arm-none-eabi-gcc -S file.c -o file.s`）。
3. 对照汇编和 C，对应参数传递、返回、栈帧使用等。
4. 用调试器 `gdb` 跟踪函数调用过程，更直观理解。

---

需要我提供完整 C + 汇编对照案例、交叉编译命令、或者 gdb 调试教程，也可以告诉我。
